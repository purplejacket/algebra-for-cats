<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>
</head>
<link
rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js"></script>
<script>
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js"></script>
<style>

    .answer{
      font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
      color: crimson;
    }
    .emphasis{
          font-family: 'Courier New', Courier, monospace;
          background-color: rgb(199, 188, 188);
          color: rgb(255, 0, 0);
          border-radius: 2pt;
    }
    .courier{
      font-family: 'Courier New', Courier, monospace;
    }
    img{
      display: flex;
    }


</style>
<body>
  <h5>1. Prove that there are infinitely many prime numbers.</h5>
  <h4 class="answer">Let's approach this question by assuming there are a finite number of prime numbers.<br>
  largestprime = the largest prime number<br>
  primelist = 2*3*5...*largestprime+1<br>
  is primelist divisible by 2? No, there is a remainder of 1.<br>
  is primelist divisible by 3? No, there is a remainder of 1.<br>
  is primelist divisible by 5? No, there is a remainder of 1.<br>
  is primelist divisible by 7? No, there is a remainder of 1.<br>
  is primelist divisible by 11? No, there is a remainder of 1.<br>
  is primelist divisible by 13? No, there is a remainder of 1.<br>
  If we repeat this process, we reach the question:<br>
  is primelist divisible by largest prime? No, there is a remainder of 1.<br>
  primelist is not divisible by largestprime, making it a prime number.<br>
  we have found a contridiction, therefore there are not a finite, but infinite number of primes.<br>
</h4>
  <h5>2. Install the <span class="emphasis">pngquant</span> command on your mac to compress png files.  We will use this for all png files going forward to conserve space.  Run the following commands, then copy the output as the answer to this question.  Run in a directory where you have a png file -- here coolFuncs.png is used as an example, replace that with your own file.</h5>

  <pre><code class="language-js">    
  brew install pngquant
  pngquant --help
  pngquant coolFuncs.png
  ls -l coolFuncs*
  </code></pre>
  <h4 class="answer">‚àö</h4>
  <pre>‚ûú  desktop brew install pngquant
    Updating Homebrew...
    ==> Auto-updated Homebrew!
    Updated 2 taps (homebrew/core and homebrew/cask).
    ==> New Formulae
    clickhouse-odbc                          texlive
    ==> Updated Formulae
    Updated 137 formulae.
    ==> Updated Casks
    Updated 84 casks.
    
    ==> Downloading https://ghcr.io/v2/homebrew/core/pngquant/manifests/2.15.1
    Already downloaded: /Users/dancedude/Library/Caches/Homebrew/downloads/
    8d940b411de4c9ea9dea6691e1eac8f0aaa125a90b7f45bebce581e31c1223ac--pngquant-2.15.1.bottle_manifest.json
    ==> Downloading https://ghcr.io/v2/homebrew/core/pngquant/blobs/sha256:ed5a067fe
    Already downloaded: /Users/dancedude/Library/Caches/Homebrew/downloads/
    81a6a77e82ca3df9a473084661c6a81cafb3e778eb8f9560b3aeac039db518f9--pngquant--2.15.1.arm64_big_sur.bottle.tar.gz
    ==> Pouring pngquant--2.15.1.arm64_big_sur.bottle.tar.gz
    üç∫  /opt/homebrew/Cellar/pngquant/2.15.1: 7 files, 177.9KB
    ‚ûú  desktop pngquant --help
    pngquant, 2.15.1 (May 2021), by Kornel Lesinski, Greg Roelofs.
       Color profiles are supported via Little CMS. Using libpng 1.6.37.
    
    usage:  pngquant [options] [ncolors] -- pngfile [pngfile ...]
            pngquant [options] [ncolors] - >stdout &lt; stdin
    
    options:
      --force           overwrite existing output files (synonym: -f)
      --skip-if-larger  only save converted files if they're smaller than original
      --output file     destination file path to use instead of --ext (synonym: -o)
      --ext new.png     set custom suffix/extension for output filenames
      --quality min-max don't save below min, use fewer colors below max (0-100)
      --speed N         speed/quality trade-off. 1=slow, 4=default, 11=fast & rough
      --nofs            disable Floyd-Steinberg dithering
      --posterize N     output lower-precision color (e.g. for ARGB4444 output)
      --strip           remove optional metadata (default on Mac)
      --verbose         print status messages (synonym: -v)
    
    Quantizes one or more 32-bit RGBA PNGs to 8-bit (or smaller) RGBA-palette.
    The output filename is the same as the input name except that
    it ends in "-fs8.png", "-or8.png" or your custom extension (unless the
    input is stdin, in which case the quantized image will go to stdout).
    If you pass the special output path "-" and a single input file, that file
    will be processed and the quantized image will go to stdout.
    The default behavior if the output file exists is to skip the conversion;
    use --force to overwrite. See man page for full list of options.
    ‚ûú  desktop pngquant test.png                                              
    ‚ûú  desktop ls -l test* 
    -rw-r--r--  1 dancedude  staff  1555351 Oct  3 11:05 test-fs8.png
    -rw-r--r--@ 1 dancedude  staff  5355796 Oct  3 11:03 test.png</pre>
  <h5>3. For the homework that was due June 25, turn it into an html file with associated image files.  Take a screenshot and put that as your answer here.  Remember:  use <span class="emphasis">pngquant</span> to compress the screenshot.
  <img src="3-fs8.png" width=700>
    <h5>4. Easy console work:
    <ul>
    <li class="courier">a = []</li>
    <li class="courier">b. for (i=0;i<=16;i++) { a.push(2**i) }</li>
    <li class="courier">c. console.table(a)</li>
  </ul>
  
  <img src="num4-fs8.png" width=200>
    <h5>5. Mental math:  Study the table you produced in the last question.  Prepare to say these numbers from memory as an exercise in class.  Use "spaced repetition" -- repeat this study on 3 different days.  On the third day write a sentence with some comments regarding what is easy and what is hard about this exercise.
  <h4 class="answer">Day 1, 2, and 3 Complete.
    This was... interesting. Mostly, I think that I will need more memorization. Not sure spaced repetition is for me. But, it was really hard.
  </h4>
      <h5>6. Write two functions (see below) that depend on Unicode.  In https://gist.github.com/ivandrofly/0fe20773bd712b303f78 you‚Äôll need lines 154, 155, 161 and 614-637.  Run all of the following <span class="emphasis">console.assert</span> commands to make sure your code is correct.  If your code is not correct you will get <span class="emphasis">Assertion failed</span> (correct code will just return undefined ... a little weird, but run with it).<br>
    a. Write a function <span class="emphasis">xToThe(n)</span> that returns a string of x to the n, where n is any integer.  Examples:<br>
      I. <span class="emphasis">console.assert(xToThe(12) == "x¬π¬≤")</span><br>
      II. <span class="emphasis">console.assert(xToThe(370) == "x¬≥‚Å∑‚Å∞")</span><br>
      III. <span class="emphasis">console.assert(xToThe(-5) == "x‚Åª‚Åµ")</span><br>
      IV. <span class="emphasis">console.assert(xToThe(1234567890) == "x¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ‚Å∞"</span><br>
      <pre><code class="language-js">    
      function xToThe(n) {
        var output = 'x';
        var nstr = n.toString();
        for (i=0; i < nstr.length; i++){
            switch(nstr[i]) {
              case '-':
                output=output+'‚Åª'
                break;
              case '0':
                output=output+'‚Å∞';
                break;
              case '1':
                output=output+'¬π';
                break;
              case '2':
                output=output+'¬≤';
                break;
              case '3':
                output=output+'¬≥';
                break;
              case '4':
                output=output+'‚Å¥';
                break;
              case '5':
                output=output+'‚Åµ';
                break;
              case '6':
                output=output+'‚Å∂';
                break;
              case '7':
                output=output+'‚Å∑';
                break;
              case '8':
                output=output+'‚Å∏';
                break;
              case '9':
                output=output+'‚Åπ';
                break;
            }
        }
        return output;
    }
    </code></pre>
    <img src='assertions6a.png' width="400">
      b. Write a function <span class="emphasis">xSub(n)</span> that returns a string of x with a subscript of n, where n is a non-negative integer.  Examples:<br>
      I. <span class="emphasis">console.assert(xSub(0) == "x‚ÇÄ");</span><br>
      II. <span class="emphasis">console.assert(xSub(4) == "x‚ÇÑ");</span><br>
      III. <span class="emphasis">console.assert(xSub(678) == "x‚ÇÜ‚Çá‚Çà");</span><br>
      <pre><code class="language-js">      function xSub(n) {
        var output = 'x';
        var nstr = n.toString();
        for (i=0; i < nstr.length; i++){
            switch(nstr[i]) {
              case '-':
                output=output+'‚Çã'
                break;
              case '0':
                output=output+'‚ÇÄ';
                break;
              case '1':
                output=output+'‚ÇÅ';
                break;
              case '2':
                output=output+'‚ÇÇ';
                break;
              case '3':
                output=output+'‚ÇÉ';
                break;
              case '4':
                output=output+'‚ÇÑ';
                break;
              case '5':
                output=output+'‚ÇÖ';
                break;
              case '6':
                output=output+'‚ÇÜ';
                break;
              case '7':
                output=output+'‚Çá';
                break;
              case '8':
                output=output+'‚Çà';
                break;
              case '9':
                output=output+'‚Çâ';
                break;
            }
        }
        return output;
    }
</code></pre>
<img src="assertionsb-fs8.png" width="700"><br>
      <h5>7. Create six different images, and list which functions you choose for each:<br><br>
  A. A graph with five degree 0 polynomial functions<br>
  B. A graph with five degree 1 polynomial functions<br>
  C. A graph with five degree 2 polynomial functions<br>
  D. A graph with five degree 3 polynomial functions<br>
  E. A graph with five degree 4 polynomial functions<br>
  F. A graph with five degree 5 polynomial functions<br>

  A.
  <pre><code class="language-js">  const a = (x) => 1;
  const b = (x) => 2;
  const c = (x) => 3;
  const d = (x) => 4;
  const e = (x) => 5;
  </code></pre>
  <img src="71-fs8.png" width="400"><br>
  B.
  <pre><code class="language-js">  const a = (x) => 2*x+1;
  const b = (x) => 1/2*x+2;
  const c = (x) => 4*3+1;
  const d = (x) => 9*x+4;
  const e = (x) => -x+5;</code></pre>
  <img src="72-fs8.png" width="400"><br>
  C.
  <pre><code class="language-js">  const a = (x) => 2*x**2 + 2*x+1;
  const b = (x) => 2*x**2 + 1/2*x+2;
  const c = (x) => 2*x**2 +4*3+1;
  const d = (x) => 2*x**2 +9*x+4;
  const e = (x) => 2*x**2 + -x+5;</code></pre>
  <img src="xy-fs8.png" width="500"><br>
  D.
  <pre><code class="language-js">  const a = (x) => 7*x**3 + 2*x**2 + 2*x+1;
  const b = (x) => 7*x**3 + 2*x**2 + 1/2*x+2;
  const c = (x) => 7*x**3 + 2*x**2 +4*3+1;
  const d = (x) => 7*x**3 + 2*x**2 +9*x+4;
  const e = (x) => 7*x**3 + 2*x**2 + -x+5;</code></pre>
  <img src="73-fs8.png" width="400"><br>
  E.
  <pre><code class="language-js">  const a = (x) => 8*x**4 + 7*x**3 + 2*x**2 + 2*x+1;
  const b = (x) => 8*x**4 + 7*x**3 + 2*x**2 + 1/2*x+2;
  const c = (x) => 8*x**4 + 7*x**3 + 2*x**2 +4*3+1;
  const d = (x) => 8*x**4 + 7*x**3 + 2*x**2 +9*x+4;
  const e = (x) => 8*x**4 + 7*x**3 + 2*x**2 + -x+5;</code></pre>
  <img src="74-fs8.png" width="400"><br>
  F.
  <pre><code class="language-js">  const a = (x) => 4*x**5 + 8*x**4 + 7*x**3 + 2*x**2 + 2*x+1;
  const b = (x) => 4*x**5 + 8*x**4 + 7*x**3 + 2*x**2 + 1/2*x+2;
  const c = (x) => 4*x**5 + 8*x**4 + 7*x**3 + 2*x**2 +4*3+1;
  const d = (x) => 4*x**5 + 8*x**4 + 7*x**3 + 2*x**2 +9*x+4;
  const e = (x) => 4*x**5 + 8*x**4 + 7*x**3 + 2*x**2 + -x + 5;</code></pre>
  <img src="75-fs8.png" width="400">

  <h5>8. Write 5 creative and complicated functions and put them all on the same graph.  This time two simple rules:<br>
  A. no pure polynomial functions<br>
  B. no use of <span class="emphasis">Math.random</span><br>
  <img src="My5funcs-fs8.png" width="700"><br>
  Unfortunately, I couldent find the functions I used for this.<br>
  <img src="Funkyfuncs-fs8.png" width="700"><br>
  <pre><code class="language-js">
    const a = (x) => Math.sin(x*2);
    const b = (x) => Math.tan(a(x));
    const c = (x) => b(x) + a(x);
    const d = (x) => a(b(c(x)));
    const e = (x) => x**x;
      </code></pre>
  <h5>9. Screeps update:<br>
  A. Show a screenshot of Screeps and describe what‚Äôs going on<br>
  B. 2 days later:  show another screenshot, and describe what has changed<br>
  C. 3 days after that:  show a third screenshot, describe what has changed,<br>
  D. Write a summary describing the whole arc of what happened<br>
  <h4 class="answer">Day 1:</h4>
  <img src="day1-fs8.png" width="400">
  <h4 class="answer">Really nothing happening here. Extremely boring. Still having some minor CPU issues.</h5>
  <h4 class="answer">Day 2:</h4>
  <img src="day2-fs8.png" width="400">
  <h4 class="answer">Ok, now some actually new and interesting stuff has been happening. I completely rebooted screeps, other than the actual code. Now I am in Shard 1.</h5>
  <h4 class="answer">Day 3:</h4>
  <img src="day3-fs8.png" width="400">
  <h4 class="answer">Rebooted again! This time I am in shard 2, and have rebooted my code. Because of this, I am afraid of attacks from tigga. Also, if you are wondering, there was a small code bug where the spawner didn't spawn creeps for a while, that was around the time I took this screenshot.</h4>
  <h4 class="answer">So, yea overall a lot of fun. I went from being extremley bored, to being excited, to rebooting, to rebooting all of my code.</h4>

  <h4 class="answer">CODE DUN DUN DUUUUUUUUN</h4>
  <h4 class="answer">Main</h4>

  <pre><code class="language-js">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');
var roleBuilder = require('role.builder');
var roleRepairer = require('role.repairer');
var roleWR = require('role.wallRepairer');
var Spawns = require('spawner');

module.exports.loop = function () {
    for(var name in Memory.creeps) {
        if(!Game.creeps[name]) {
            delete Memory.creeps[name];
            console.log('Clearing non-existing creep memory:', name);
        }
    }
    var tower = Game.getObjectById('TOWER_ID');
    if(tower) {
        var closestDamagedStructure = tower.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: (structure) => structure.hits < structure.hitsMax
        });
        if(closestDamagedStructure) {
            tower.repair(closestDamagedStructure);
        }

        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if(closestHostile) {
            tower.attack(closestHostile);
        }
        
        var closestDamagedCreep = tower.pos.findClosestByRange(FIND_MY_CREEPS, {filter: (creep) => creep.hits < creep.hitsMax});
    }
        let creepsInRoom = Game.spawns.Spawn1.room.find(FIND_MY_CREEPS);
        var h = _.sum(creepsInRoom, (c) => c.memory.role == 'harvester');
        var u = _.sum(creepsInRoom, (c) => c.memory.role == 'upgrader');
        var b = _.sum(creepsInRoom, (c) => c.memory.role == 'builder');
        var r = _.sum(creepsInRoom, (c) => c.memory.role == 'repairer');
        var wR = _.sum(creepsInRoom, (c) => c.memory.role == 'wallRepairer');
        var dm = _.sum(creepsInRoom, (c) => c.memory.role == 'drop miner');
        var bodyparts = [WORK,WORK,WORK,CARRY,MOVE,MOVE,MOVE,MOVE]
        if (h < 1){
            Game.spawns.Spawn1.spawnCreep([WORK,CARRY,MOVE], 'savior' + Math.round(Math.random()*20).toString(), {memory: {role: 'harvester', working: true}});
        }
        else if (h < 3){
            Game.spawns.Spawn1.spawnCreep(bodyparts, 'h' + Math.round(Math.random()*1029302).toString(), {memory: {role: 'harvester', working: true}});
        }
        else if (u < Game.spawns.Spawn1.memory.minUpgraders){
            Game.spawns.Spawn1.spawnCreep(bodyparts, 'u' + Math.round(Math.random()*1029302).toString(), {memory: {role: 'upgrader', working: true}});
        }
        else if (b < Game.spawns.Spawn1.memory.minBuilders){
            Game.spawns.Spawn1.spawnCreep(bodyparts, 'b' + Math.round(Math.random()*1029302).toString(), {memory: {role: 'builder', working: true}});
        }
        else if (r < Game.spawns.Spawn1.memory.minRepairers){
            Game.spawns.Spawn1.spawnCreep(bodyparts, 'r' + Math.round(Math.random()*1029302).toString(), {memory: {role: 'repairer', working: true}});
        }
        else if (wR < 2){
            Game.spawns.Spawn1.spawnCreep(bodyparts, 'wR' + Math.round(Math.random()*1029302).toString(), {memory: {role: 'wallRepairer', working: true}});
        }
        else if (dm < 2){
            Game.spawns.Spawn1.spawnCreep([WORK,WORK,WORK,WORK,WORK,MOVE], 'dm' + Math.round(Math.random()*1029302).toString(), {memory: {role: 'drop miner'}});
        }
        
        // Spawns.play();

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
        if(creep.memory.role == 'repairer') {
            roleRepairer.run(creep);
        }
        if(creep.memory.role == 'drop miner') {
            roleRepairer.run(creep);
        }
        if(creep.memory.role == 'wallRepairer') {
            roleWR.run(creep);
        }
    }
};</code></pre>
<h4 class="answer">builder</h4>
<pre><code class="language-js">  var h = require('role.harvester');
  var roleBuilder = {
  
      /** @param {Creep} creep **/
      run: function(creep) {
  
          if(creep.memory.building && creep.store[RESOURCE_ENERGY] == 0) {
              creep.memory.building = false;
              creep.say('üîÑ harvest');
          }
          if(!creep.memory.building && creep.store.getFreeCapacity() == 0) {
              creep.memory.building = true;
              creep.say('üöß build');
          }
  
          if(creep.memory.building) {
              var targets = creep.room.find(FIND_CONSTRUCTION_SITES);
              if(targets.length) {
                  if(creep.build(targets[0]) == ERR_NOT_IN_RANGE) {
                      creep.moveTo(targets[0]);
                  }
              }
              else{
                  h.run(creep);
              }
          }
          else {
              var sources = creep.room.find(FIND_SOURCES);
              if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                  creep.moveTo(sources[0]);
              }
          }
      }
  };
  
  module.exports = roleBuilder;</code></pre>
  <h4 class="answer">harvester</h4>
<pre><code class="language-js">  var roleUpgrader = require('role.upgrader');

  var roleHarvester = {
      run: function(creep){
          if(creep.memory.harvesting && creep.store.getFreeCapacity(RESOURCE_ENERGY) == 0){
              creep.memory.harvesting = false;
              creep.say('üîÑ');
          }else if(!creep.memory.harvesting && creep.store[RESOURCE_ENERGY] == 0){
              creep.memory.harvesting = true;
              creep.say('üåæ');
          }
          
          if(creep.memory.harvesting){
              var droppedResource = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES);
              if (droppedResource){
                  creep.pickup(droppedResource);
              }
              var closestSource = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);
              var e = creep.harvest(closestSource);
              if(e == ERR_NOT_IN_RANGE){
                  creep.moveTo(closestSource);
              }       
          }else{
              var target = creep.pos.findClosestByPath(FIND_MY_STRUCTURES, {
                  filter: (s) => (s.structureType == STRUCTURE_SPAWN 
                                   || s.structureType == STRUCTURE_EXTENSION
                                   || s.structureType == STRUCTURE_TOWER)
                                   && s.store.getFreeCapacity(RESOURCE_ENERGY) > 0
              });
              if(target){
                  var e = creep.transfer(target, RESOURCE_ENERGY);
                  if(e == ERR_NOT_IN_RANGE){
                      creep.moveTo(target);
                  }
              }else {
                  roleUpgrader.run(creep);
              }
          }
      }
  };
  module.exports = roleHarvester;</code></pre>
  <h4 class="answer">repairer</h4>
<pre><code class="language-js">  var roleBuilder = require('role.builder');

  module.exports = {
      // a function to run the logic for this role
      run: function(creep) {
          // if creep is trying to repair something but has no energy left
          if (creep.memory.working == true && creep.carry.energy == 0) {
              // switch state
              creep.memory.working = false;
          }
          // if creep is harvesting energy but is full
          else if (creep.memory.working == false && creep.carry.energy == creep.carryCapacity) {
              // switch state
              creep.memory.working = true;
          }
  
          // if creep is supposed to repair something
          if (creep.memory.working == true) {
              // find closest structure with less than max hits
              // Exclude walls because they have way too many max hits and would keep
              // our repairers busy forever. We have to find a solution for that later.
              var structure = creep.pos.findClosestByPath(FIND_STRUCTURES, {
                  // the second argument for findClosestByPath is an object which takes
                  // a property called filter which can be a function
                  // we use the arrow operator to define it
                  filter: (s) => s.hits < s.hitsMax && s.structureType != STRUCTURE_WALL
              });
  
              // if we find one
              if (structure != undefined) {
                  // try to repair it, if it is out of range
                  if (creep.repair(structure) == ERR_NOT_IN_RANGE) {
                      // move towards it
                      creep.moveTo(structure);
                  }
              }
              // if we can't fine one
              else {
                  // look for construction sites
                  roleBuilder.run(creep);
              }
          }
          // if creep is supposed to harvest energy from source
          else {
              // find closest source
              var source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);
              // try to harvest energy, if the source is not in range
              if (creep.harvest(source) == ERR_NOT_IN_RANGE) {
                  // move towards the source
                  creep.moveTo(source);
              }
          }
      }
  };</code></pre>
  <h4 class="answer">upgrader</h4>
<pre><code class="language-js">        var roleUpgrader = {

          /** @param {Creep} creep **/
          run: function(creep) {
      
              if(creep.memory.upgrading && creep.store[RESOURCE_ENERGY] == 0) {
                  creep.memory.upgrading = false;
                  creep.say('harvest üçî');
              }
              if(!creep.memory.upgrading && creep.store.getFreeCapacity() == 0) {
                  creep.memory.upgrading = true;
                  creep.say('upgrade ‚ö°Ô∏è');
              }
      
              if(creep.memory.upgrading) {
                  if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
                      creep.moveTo(creep.room.controller);
                  }
              }
              else {
                  var sources = creep.room.find(FIND_SOURCES);
                  if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                      creep.moveTo(sources[0]);
                  }
              }
          }
      };
      
      module.exports = roleUpgrader;</code></pre>
      <h4 class="answer">wallRepairer</h4>
<pre><code class="language-js">  var roleBuilder = require('role.builder');

  module.exports = {
      // a function to run the logic for this role
      run: function(creep) {
          // if creep is trying to repair something but has no energy left
          if (creep.memory.working == true && creep.carry.energy == 0) {
              // switch state
              creep.memory.working = false;
          }
          // if creep is harvesting energy but is full
          else if (creep.memory.working == false && creep.carry.energy == creep.carryCapacity) {
              // switch state
              creep.memory.working = true;
          }
  
          // if creep is supposed to repair something
          if (creep.memory.working == true) {
              // find closest structure with less than max hits
              // Exclude walls because they have way too many max hits and would keep
              // our repairers busy forever. We have to find a solution for that later.
              var structure = creep.pos.findClosestByPath(FIND_STRUCTURES, {
                  // the second argument for findClosestByPath is an object which takes
                  // a property called filter which can be a function
                  // we use the arrow operator to define it
                  filter: (s) => s.hits < s.hitsMax && s.structureType == STRUCTURE_WALL
              });
  
              // if we find one
              if (structure != undefined) {
                  // try to repair it, if it is out of range
                  if (creep.repair(structure) == ERR_NOT_IN_RANGE) {
                      // move towards it
                      creep.moveTo(structure);
                  }
              }
              // if we can't fine one
              else {
                  // look for construction sites
                  roleBuilder.run(creep);
              }
          }
          // if creep is supposed to harvest energy from source
          else {
              // find closest source
              var source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);
              // try to harvest energy, if the source is not in range
              if (creep.harvest(source) == ERR_NOT_IN_RANGE) {
                  // move towards the source
                  creep.moveTo(source);
              }
          }
      }
  };
</code></pre>
  <h5>10. Zombie Flexbox game.  Go through two more levels.  Take two screenshots at interesting moments and explain all of the Flex details you are working on.</h5>
  <h4 class="answer">I think the second image pretty much explains every new thing I have found. display: flex to turn it on, justify-content to aim, align-items to align them, and align-self to single out one. Also, the levels here are 3.9 and 3.10</h4>
    <img src="f3.png" width="300"><br>
    <img src="f4.png" width="300">
    <h5>11. What is "nullish coalescing", the new operator <span class="emphasis">??</span> introduced into JavaScript in the year 2020?  Do some research/reading, then explain these:<br>
<ol class="courier">
  A. x = null; y = x ?? "hello";<br>
  B. x = undefined; y = x ?? "hello";<br>
  C. x = 3.14; y = x ?? "hello";<br>
  D. x = false; y = x ?? "hello";<br>
  E. x = NaN; y = x ?? "hello";<br>
  F. x = ""; y = x ?? "hello";<br>
  G. x = []; y = x ?? "hello";<br>
  H. x = 0; y = x ?? "hello";<br>
  I. x = {}; y = x ?? "hello";<br>
</ol>
  <h4 class="answer" class="courier">The ?? operator (or nullish coalescing) is as follows:
    If the first parameter is any nullish value (null or undefined), it becomes the second parameter. If it is truthy then it chooses that first parameter.</h4>
  <h5>12. Go to the Tensorflow Playground -- <a href="https://playground.tensorflow.org">https://playground.tensorflow.org</a> -- and solve each of the four datasets.  Take a screenshot of each solution.  Discuss.
    <h4 class="answer">Please note the following screenshots before reading further. Done? Good. This took me around an hour to play around with. Here is what I found:
      For image 4: this one can be messed up really easily, so I just took a wack at it and after about 20 minutes I came up with just using only 1 hidden module, with only 1 segment. This runs a little bit slowly, but works.
      For image 1: this one was super easy, it is really hard to mess this up. I would reccomend this one for beginners.
      The other 2 are really nothing special, but they do take quite a bit of time.
      Last thing of note, PLEASE DO NOT put the timing to high, because it will overload it.
    </h4>
    <img src="12a-fs8.png" width="400"><br>
    <img src="12b-fs8.png" width="400"><br>
    <img src="12c-fs8.png" width="400"><br>
    <img src="12d-fs8.png" width="400"><br>
<script>
  </script>
</body>
</html>